# 网络协议

OSI网络协议模型：应用层，表示层，会话层，传输层，网络层，    数据链路层，物理层。

TCP/IP协议模型：应用层，              传输层，互连网络层，网络接口层


## HTTP协议

**HTTP**（超文本传输协议）是应用层协议，构建于TCP/IP协议之上，默认端口是80，是无连接状态的，是**请求-应答**模式。

HTTP定义了与服务器交互的不同方法，最基本的四种为：GET/POST/PUT/DELETE，分别对应着 查/增/改/删四个操作。

1. GET用于信息获取。获取信息不回修改信息，所以应该是安全的，而且同一URL的多次请求结果是相同（幂等）。
2. POST表示改变服务器资源。
3. PUT与POST相近，表示创建或者更新服务器资源。
4. DELETE表示删除操作。

**注意**

1. GET也可以携带参数信息，需要添加到URL中，可提交数据量受到URL长度限制，**HTTP协议规范没有URL长度限制，这个限制是特定浏览器或者服务器的限制。**
2. 在HTTP中，PUT被定义为idempotent（幂等），而POST不是。例：修改博客名称，如果发送两次网络请求，修改完成之后变成两篇博客，使用POST;如果是后一次把第一次覆盖，就是用PUT。

### Keep-Alive 持久连接

由于HTTP是请求-应答模式，所以需要频繁的创建连接-关闭连接。

在请求头中添加```Connection: Keep-Alive```，则服务器会在响应头中也添加字段，并且这次的连接将会被保持。在HTTP1.1中所有的连接都是默认被保持的，在请求头中加入```Connection: close```才关闭；```Keep-Alive: timeout=5, max=100```:表示 通道保持5秒，传输最多100次。

使用长连接，确定本次传输完成：
* 判断传输数据是否达到```Content-Length```的大小。
* 动态生成的文件没有```Content-Length```，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束。

### HTTP Pipelining（HTTP 管线化）

默认HTTP传输层连接每次只能承载一个HTTP请求和响应，使用长连接多个请求时，在收到上一次请求的响应后，在发送下一个请求。

HTTP管线化是多个HTTP请求不需要等待服务器响应，类似于```请求1->请求2->请求3->响应1->响应2->响应3```。

注意:
* 管线化通过持久连接实现，仅支持HTTP1.1
* 只有GET和HEAD请求可以进行管线化，POST有限制。
* 管线化不影响响应顺序。

## TCP协议

TCP是一种面向连接的可靠的字节流传输协议，只能点对点通讯。使用校验和，确认和重传机制保证可靠传输。TCP给数据分节排序，并使用累积确认保证数据的顺序不变和非重。通过滑动窗口机制实现流量控制，通过动态改变窗口大小进行拥塞控制。

TCP不能保证数据一定送达，如果不能送达，通过放弃重传并且中断连接通知用户。

### 三次握手

目的是建立服务器和客户端的连接。

* 第一次握手(SYN=1, seq=x)：客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口。发送完毕后，客户端进入 SYN_SEND 状态。
* 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)：服务器发回确认包，发送完毕后，服务器端进入 SYN_RCVD 状态。
* 第三次握手(ACK=1，ACKnum=y+1)：客户端再次发送确认包，发送完毕后，客户端进入 ESTABLISHED（已建立） 状态。服务器收到确认包后，也进入ESTABLISHED（已建立） 状态。

拒绝服务攻击（DOS）：伪造大量不存在的IP地址，向服务器发起请求（第一次握手），服务器会回复确认包，并等待客户端确认，由于地址不存在，服务器需要不断重发至超时，导致服务器资源被占用，正常请求不能进行，甚至网络瘫痪。

### 四次挥手

目的是为了断开服务器和客户端的连接，任意一方均可调用。

* 第一次挥手(FIN=1，seq=x)：客户端发送断连请求包，表示已没有数据发送，但可接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。
* 第二次挥手(ACK=1，ACKnum=x+1)：服务器发送确认客户端的断连包，表明已收到，但未准备好断开。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端收到后进入FIN_WAIT_2状态。
* 第三次挥手(FIN=1，seq=y)：服务器准备好断开连接，并想客户端发送关闭请求。发送完毕进入 LAST_ACK 状态。
* 第四次挥手(ACK=1，ACKnum=y+1)：客户端收到服务器关闭请求，发送确认包。发送完毕之后进入TIME_WAIT状态，等待可能出现的要求重传包。服务器收到确认包后关闭连接，并进入 CLOSED 状态。

客户端等待固定时间（两个最大段生命周期，2 Maximum Segment Lifetime）之后，没有收到服务器的ACK（应答），认为服务器已正常关闭，于是自己也关闭，进入 CLOSED 状态。
