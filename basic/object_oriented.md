# 面向对象的一些问题

面向对象的三大要素：继承、多态、封装。

## 继承

继承可以很好的解决代码复用的问题，但是也带来了耦合，业务需求的复杂，子类的增多，就可能出现超级父类（高耦合），如果这时一旦需要修改父类，会牵一发而动全身。

选择继承时要符合以下三大要点：

* 父类只是给子类提供服务，不涉及子类业务逻辑；
* 父类子类层级关系明显，功能划分清晰；
* 父类的所有变化，都**需要**在子类中体现，也就是此时耦合已成为需求。

就目前大多数需求来看，必须使用继承的场景不太多，主要是代码复用的场景比较多，大部分都可以用组合替代继承，按职责进行模块拆分，使用delegate进行交互。

继承比较符合直觉，但是组合需要更好的抽象能力，但是更利于后期需求变化的维护。
优先考虑组合，万不得已不要使用继承。


## 多态

使用多态时会面临的四种情况：

1. 父类有部分public方法不需要也允许子类覆盖重写：例如，希望在某个父类方法调用之前，执行一些其他操作，这时如果在父类方法中添加，进**使得一个对象引入了原本不属于它的业务逻辑**，如果引入的额外逻辑有其他模块的依赖，增加了耦合。
2. 父类有部分方法是子类必须要覆盖重写的，父类只是个空方法：这个场景很多，例如网络请求中的api，一般父类只是一个默认或者空的方法，需要子类去实际指定api。
3. 父类有些方法是可选覆盖重写的，重写以子类为准：一般场景是做拦截器，或者监听器，例如UIViewController 的 viewWillAppear等，在父类执行某个方法之前或者之后，可以让子类添加额外的操作。
4. 父类有些方法即便被覆盖重写，父类方法仍需执行：就是很常见的调用[super method]，例如UITableViewCell重写了layoutSubviews方法，如果不调用父类方法，会有问题的（曾经找了很久的分割线的问题）。

### 面向接口编程（Interface Oriented Programming, IOP

IOP 可以比较好的解决上述多态的问题。父类的方法必须子类重写的和可选重写的分别剥离出来成为接口，这样子类就可以按需进行覆重，父类也不用引入额外的逻辑。

* 将子类与可能被子类引入的不相关逻辑剥离开来，提高子类的可重用性，降低迁移时可能的耦合；
* **接口实际上是子类头上的金箍，规范了子类哪些必须实现，哪些可选实现**。不在接口定义里的父类的方法，事实上就是不建议覆重的方法。

判断是否使用多态：

* 要能保持对象的单纯，不涉及具体业务。
* 覆重的方法是业务的一部分使用IOP，这样可以根据不同业务进行不同的覆重。

保证**对象角色单纯**的情况下可以引入多态，如果父类运行时需要子类提供中间数据，应当使用IOP。

选择覆重：不要在覆重的方法里做和这个方法本意不想管的事情。如果需要做其他的事，而父类没有，可以通过**在覆重的方法里使用IOP，把其他事情剥离出去**来弥补，负责实现接口的可以是self，也可以是其他的，这样可以提高灵活性，还不影响整体功能。

多态很容易被滥用，但是很容易引入不属于对象初衷的逻辑，在这方面IOP是更优的解决方案。使用多态时，需要有清晰的**角色**概念，做好角色划分，是拦截器的方法，就指定一个拦截器接口，有另一个对象（逻辑上的其他对象，也可以是自己）去实现这个方法集。不要让一个对象在**逻辑上**既是拦截器，又是业务。

IOP分离了定义和实现，带来更好的灵活性，既可以对语言过高的自由度有一个限制，也可以允许同一接口的不同实现能够合理组合。

##参考：https://casatwy.com/index.html