# 选择排序

每次从当前队列中选取极值，放到有序队列的末尾。因此需要标记下当前的极值，轮询一遍之后比较出极值的下标，进行交换，是一个不稳定排序。

时间复杂度是:O(n^2)，空间复杂度是:O(1)。

测试数据：
```
int arr[17] = {3,4,2,1,5,6,7,8,0,50,1,33,24,5,-4,7,0}
```


```
void selectSort(int arr[], int len) {
    for (int i = 0; i < len; i++) {
        int minIndex = i; // 标记当前位置为最小值
        for (int j = i+1; j < len; j++) { // 遍历无序部分进行比较，将最小值下标赋值给minIndex
            minIndex = arr[minIndex]<arr[j]?minIndex:j;
        }
        // 将minIndex与i进行交换
        if (i!=minIndex) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
        printf("i = %d : ", i);
        arrayLog(arr, len);
    }
}
```

输出为：
```
i = 0 : -4,4,2,1,5,6,7,8,0,50,1,33,24,5,3,7,0,
i = 1 : -4,0,2,1,5,6,7,8,0,50,1,33,24,5,3,7,4,
i = 2 : -4,0,0,1,5,6,7,8,2,50,1,33,24,5,3,7,4,
i = 3 : -4,0,0,1,5,6,7,8,2,50,1,33,24,5,3,7,4,
i = 4 : -4,0,0,1,1,6,7,8,2,50,5,33,24,5,3,7,4,
i = 5 : -4,0,0,1,1,2,7,8,6,50,5,33,24,5,3,7,4,
i = 6 : -4,0,0,1,1,2,3,8,6,50,5,33,24,5,7,7,4,
i = 7 : -4,0,0,1,1,2,3,4,6,50,5,33,24,5,7,7,8,
i = 8 : -4,0,0,1,1,2,3,4,5,50,5,33,24,6,7,7,8,
i = 9 : -4,0,0,1,1,2,3,4,5,5,50,33,24,6,7,7,8,
i = 10 : -4,0,0,1,1,2,3,4,5,5,6,33,24,50,7,7,8,
i = 11 : -4,0,0,1,1,2,3,4,5,5,6,7,24,50,7,33,8,
i = 12 : -4,0,0,1,1,2,3,4,5,5,6,7,7,50,24,33,8,
i = 13 : -4,0,0,1,1,2,3,4,5,5,6,7,7,8,24,33,50,
i = 14 : -4,0,0,1,1,2,3,4,5,5,6,7,7,8,24,33,50,
i = 15 : -4,0,0,1,1,2,3,4,5,5,6,7,7,8,24,33,50,
i = 16 : -4,0,0,1,1,2,3,4,5,5,6,7,7,8,24,33,50,
-4,0,0,1,1,2,3,4,5,5,6,7,7,8,24,33,50,
```

> 可以发现从i=13时已经是有序数列了，后面的都是遍历了，那么有必要像冒泡那样，当没有进行过交换之后就默认已经结束了呢？

答案是否定的。

假设数组大部分是有序的例如：{1,2,3,4,5,6,5}，那么遍历第一次没有进行过交换，就直接结束排序了，所得结果还是未排序的。

选择排序只是判断无序部分的第一个值与后面的值进行比较交换，并不会看被交换到后面的值会不会再次交换到前面，这就是不稳定排序的表现。